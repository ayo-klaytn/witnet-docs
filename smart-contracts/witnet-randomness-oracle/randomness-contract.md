# WitnetRandomness utility contract

The [`WitnetRandomness` contract](./api-reference.md#WitnetRandomness), also known as the "**Witnet Randomness Oracle**", is the easiest and most convenient way to generate EVM-agnostic and realiable randomness for your smart contracts. 

The Witnet Foundation sustains a pre-deployed instance of the `WitnetRandomness` contract in practically all the EVM-compatible chains that are already integrated with the Witnet side-chain: 

  {% content-ref url="contract-addresses.md" %}
  [contract-addresses.md](contract-addresses.md)
  {% endcontent-ref %}  

While the `WitnetRandomness` contract internally uses an instance of the low-level Witnet Randomness Request explained on a [previous article](./randmoness-requests.md), this contract implements also the whole request/resolution asynchronous flow involved in the resolution of a data request in the context of the Witnet side-chain.

Moreover, the same instance can be safely and concurrently used by any number of indepent applications running within the same EVM-chain (i.e. any of those currently supported by the Witnet side-chain). 

  {% hint style="info" %}
  Because of this, you may even have the chance to reuse randomness previously requested by others _**at no cost**_ (ðŸŽ‰), while having the certainty that the acquired randmoness was independently generated by the Witnet side-chain strictly after any given block number.
  {% endhint %}

  {% hint style="success" %}
  And therefore, depending on the time-response constraints of your own app, the Witnet Randomness Oracle becomes the cheapest side-chain mechanism to generate reliable randomness in the whole crypto arena (ðŸ’£).
  {% endhint %}

In a nutshell, by using a `WitnetRandomness` instance, you just need to care for requesting and paying for new randomness at any given time (i.e. `randomize() payable`), and eventually fetching the Witnet-provided randomness value (i.e. `isRandomized(uint256)`, `getRandomnessAfter(uint256)`). As simple as that ;)

  {% content-ref url="api-reference.md" %}
  [api-reference.md](api-reference.md)
  {% endcontent-ref %}  


## Best practices

- The `WitnetRandomness` contract is not owned, so anyone is actually allowed to either request new randomness (i.e. `randomize()`), or get previously solved randomness from storage (i.e. `isRandomized(uint _blockNumber)`, `getRandomnessAfter(uint _blockNumber)`).

- Besides, you or your contract will be able to request for new randomness (i.e. `randomize() payable`), even if other previous randomness requests (either coming from you, or other apps) were still pending to be solved.

- The `WitnetRandomness`contract is "clonable", which means that you, or your contract, may cheaply create your own cloned copy as a means to gain ownership of the self-contained `WitnetRequestRandomness` contract, and therefore be allowed to change the _witnessing parameters_ of the low-level Randomness Request that gets posted to the Witnet side-chain. 

- The `WitnetRandomness`contract provides the `random(uint32 _range, uint256 _nonce, uint256 _block)` and `random(uint32 _range, uint256 _nonce, bytes32 _seed)` helper functions. These functions guarantee that different contracts/apps reading from same randomness request will actually get _completely different random sequences of **uniformly distributed numbers**_, within a given range, and doing so while _keeping complexity under **O(1)**_ (ðŸŽ‰).

- Most of all: the `WitnetRandomness`contract guarantees the returned randomness to be the one requested at the given block number, or the _very next_ randomness request posted after the given block if there was none posted back then, or if the ones posted after that got reverted for whatever reason at the Witnet side-chain level.

  {% hint style="success" %}
  This logic alone protects the **Witnet Randomness Oracle** against front-running attacks from mallicious miners at the EVM-chain level (ðŸ’£). 
  {% endhint %}

- Once you call on `randomize() payable`, you should not allow any change in your smart contract state that alters the outcome of whatever the requested randomness is planned to be used for. 

  {% hint style="info" %}
  Just call on the `isRandomized(uint256)` method, passing the block number at which the `randomize() payable` call got mined, as to check for readiness of the requested randomness.
  {% endhint %}


## Security concerns 

- While `WitnetRandomness` is not owned, the self-contained **WitnetRandomnessRequest** it is (i.e. [`wintetRandomnessRequest()`](./api-reference.md#IWitnetRandomness)). This enables the operator of the `WitnetRandomness` instance to eventually update the *witnessing parameters* of the underlying low-level Randomenss Request that gets posted to the Witnet side-chain. Please, have in mind, though:

  - (a) the RAD bytecode, accesible via the [`template()` method](./api-reference.md#IWitnetRequestRandomness)), will foerever remain immutable;

  - (b) the *witnessing parameters* part of the `WitnetRequestRandomness` may eventually turn immutable at the time the `WitnetRandomness` operator (i.e. either the deployer, or the cloner if interacting with a cloned copy), decides to renounce its ownership (i.e. by calling to `renounceOwnership()`). 
  
  {% hint style="success" %}
  This back door of letting the `WitnetRandomness` operator modify the *witnessing parameters* of the underlying request, is left open as to provide a means for adapting to eventual high-load situations within the Witnet side-chain.
  {% endhint %}

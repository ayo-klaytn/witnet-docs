# Generating Randomness in your Smart Contracts

There are two major approaches to generate unpredictable and malleable randomness from the Witnet oracle:

* Using the **Witnet Randomness Contract**, also known as the "Witnet Randomness Oracle", that can be used by practically all kind of applications, and that it has been already pre-deployed by the Witnet Foundation on all chains eventually supported by the Witnet oracle:

  * This contract implements the whole request/resolution asynchronous flow in a general, secure and complete way, so you, or your smart contracts, just need to care for requesting new randomness (i.e. `randomize() payable`), and eventually fetching the Witnet-provided randomness (i.e. `isRandomized(uint256)`, `getRandomnessAfter(uint256)`).

  * As the Randomness Contract can be concurrently used by multiple apps within the same chain, you may have the chance to reuse the randomness requested by others, _at no cost_, while having the certainty that the parasitized randomness value was independently generated by the Witnet oracle after any given block number. 

  {% content-ref url="randomness-contract.md" %}
  [randomness-contract.md](randomness-contract.md)
  {% endcontent-ref %}

  {% content-ref url="contract-addresses.md" %}
  [contract-addresses.md](contract-addresses.md)
  {% endcontent-ref %}

* Posting a low-level **Witnet Randomness Request** to the [Witnet Request Board](../apis-and-http-get-post-oracle/witnet-request-board.md) entrypoint:

  * You will have full low-level control of the whole request/resolution asynchronous flow that runs between the EVM and the Witnet side-chain.

  * And so, you will have to implement an ad-hoc logic within your smart contract: as to (a), detect when a randomness request gets eventually solved by the Witnet oracle; as to (b), use that randomness as a seed to whatever random distribution better suits your application; but also as to (c) deal with possible delays or resolution reverts that may arise.